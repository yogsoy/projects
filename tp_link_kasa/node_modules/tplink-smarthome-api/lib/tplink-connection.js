'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const Queue = require('promise-queue');

const EventEmitter = require('events');

class TplinkConnection extends EventEmitter {
  constructor(device) {
    var _this;

    super();
    _this = this;
    this.device = device;
    this.client = device.client;
    this.sharedSocket = null;
    this.queue = new Queue(1, Infinity);
    this.on('timeout', () => {
      this.log.debug('TplinkConnection.timeout()', this.host, this.port);
      this.queue.add(
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        _this.close();
      }));
    });
  }
  /**
   * @private
   */


  get host() {
    return this.device.host;
  }
  /**
   * @private
   */


  get port() {
    return this.device.port;
  }
  /**
   * @private
   */


  get log() {
    return this.client.log;
  }
  /**
   * @private
   */


  getSocket(Constructor, reuseSocket) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.log.debug(`TplinkConnection.getSocket(%j)`, {
        reuseSocket
      });

      if (reuseSocket && _this2.sharedSocket != null) {
        _this2.log.debug(`TplinkConnection.getSocket(): reusing shared socket`);

        if (_this2.sharedSocket.socket != null && _this2.sharedSocket.isBound) {
          return _this2.sharedSocket;
        }

        _this2.log.debug(`TplinkConnection.getSocket(): recreating shared socket`);
      }

      const socket = new Constructor(_this2.client.getNextSocketId(), _this2.client.log);
      yield socket.createSocket();

      if (reuseSocket) {
        socket.unref(); // let node exit cleanly if socket is left open

        _this2.sharedSocket = socket;
      }

      return socket;
    })();
  }

  send(payload, {
    timeout,
    reuseSocket,
    reuseSocketTimeout
  } = {}) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.log.debug(`TplinkConnection.send(%j)`, {
        payload,
        timeout,
        reuseSocket,
        reuseSocketTimeout
      });

      if (reuseSocketTimeout != null) {
        _this3.setTimeout(reuseSocketTimeout);
      }

      let socket;
      return _this3.queue.add(
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        try {
          socket = yield _this3.getSocket(reuseSocket);
          let response = yield socket.send(payload, _this3.port, _this3.host, {
            timeout
          });

          if (!reuseSocket) {
            socket.close();
          }

          return response;
        } catch (err) {
          _this3.log.error(`UDP/TCP Error: %s`, err);

          if (socket && socket.isBound) socket.close();
          throw err;
        }
      }));
    })();
  }

  close() {
    if (this.sharedSocket && this.sharedSocket.isBound) {
      this.log.debug('TplinkConnection.close()');
      this.sharedSocket.close();
    }
  }
  /**
   * @private
   */


  setTimeout(timeout) {
    if (this.timer) {
      clearTimeout(this.timer);
    }

    if (timeout > 0) {
      this.timer = setTimeout(() => {
        this.emit('timeout');
      }, timeout);
    }
  }

}

module.exports = TplinkConnection;