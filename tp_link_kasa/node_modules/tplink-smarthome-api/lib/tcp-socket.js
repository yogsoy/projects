'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const Queue = require('promise-queue');

const net = require('net');

const _require = require('tplink-smarthome-crypto'),
      encryptWithHeader = _require.encryptWithHeader,
      decrypt = _require.decrypt;

class TcpSocket {
  constructor(socketId, log) {
    this.socketId = socketId;
    this.log = log;
    this.socket = null;
    this.isBound = false;
    this.queue = new Queue(1, Infinity);
  }

  createSocket() {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.log.debug(`[${_this.socketId}] TcpSocket.createSocket()`);

      if (_this.socket) {
        throw new Error('Socket Already Created');
      }

      return new Promise((resolve, reject) => {
        _this.log.debug(`[${_this.socketId}] TcpSocket.createSocket()`);

        try {
          _this.socket = new net.Socket();
          resolve(_this.socket);
        } catch (err) {
          _this.log.error(`TCP Error (createSocket): %s`, err);

          reject(err);
        }
      });
    })();
  }

  send(payload, port, host, {
    timeout
  } = {}) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _this2.log.debug(`[${_this2.socketId}] TcpSocket.send(%j)`, {
        payload,
        port,
        host,
        timeout
      });

      return _this2.queue.add(
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        try {
          let response = yield _this2.sendAndGetResponse(payload, port, host, timeout);
          return response;
        } catch (err) {
          _this2.log.error(`TCP Error:`, err);

          if (_this2.isBound) _this2.close();
          throw err;
        }
      }));
    })();
  }

  close() {
    this.log.debug(`[${this.socketId}] TcpSocket.close()`);
    this.socket.end();
    this.isBound = false;
    this.isConnected = false;
  }

  destroy() {
    this.log.debug(`[${this.socketId}] TcpSocket.destroy()`);
    this.socket.destory();
    this.isBound = false;
    this.isConnected = false;
  }

  unref() {
    return this.socket.unref();
  }
  /**
   * @private
   */


  sendAndGetResponse(payload, port, host, timeout) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return new Promise((resolve, reject) => {
        let timer;
        let deviceDataBuf;
        let segmentCount = 0;
        let decryptedMsg;
        const socket = _this3.socket;

        const setSocketTimeout = timeout => {
          if (timer != null) clearTimeout(timer);

          if (timeout > 0) {
            _this3.timer = setTimeout(() => {
              _this3.log.debug(`[${_this3.socketId}] TcpSocket: timeout(${timeout})`);

              reject(new Error('TCP Timeout'));
            }, timeout);
          }
        };

        setSocketTimeout(timeout);
        socket.removeAllListeners('data');
        socket.on('data', data => {
          segmentCount += 1;

          if (deviceDataBuf === undefined) {
            deviceDataBuf = data;
          } else {
            deviceDataBuf = Buffer.concat([deviceDataBuf, data], deviceDataBuf.length + data.length);
          }

          const expectedMsgLen = deviceDataBuf.slice(0, 4).readInt32BE();
          const actualMsgLen = deviceDataBuf.length - 4;

          if (actualMsgLen >= expectedMsgLen) {
            setSocketTimeout(0);

            try {
              decryptedMsg = decrypt(deviceDataBuf.slice(4)).toString('utf8');

              _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:data: ${decryptedMsg}`);
            } catch (err) {
              _this3.log.error(`Error parsing JSON: %s\nFrom: [${socket.remoteAddress} ${socket.remotePort}] TCP ${segmentCount} ${actualMsgLen}/${expectedMsgLen} Original: [%s] Decrypted: [${decryptedMsg}]`, err, deviceDataBuf);

              reject(err);
            } // socket.end();

          }
        });
        socket.once('end', hadError => {
          _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:end`); // setSocketTimeout(0);
          // reject(new Error('TCP Socket End'));

        });
        socket.once('close', hadError => {
          _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:close, hadError:`, hadError);

          setSocketTimeout(0);
          _this3.isConnected = false;

          if (hadError || segmentCount === 0) {
            return reject(new Error(`TCP Socket Closed. segmentCount: ${segmentCount} hadError: ${hadError}`));
          }

          if (decryptedMsg !== '') {
            return resolve(JSON.parse(decryptedMsg));
          }

          resolve(decryptedMsg);
        });
        socket.once('error', err => {
          _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:error`, err);

          setSocketTimeout(0);
          socket.destroy();
          reject(err);
        });
        const encyptedPayload = encryptWithHeader(payload);

        _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:send payload.length`, encyptedPayload.length);

        const doWrite = () => {
          const writeRet = socket.write(encyptedPayload);

          _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:send:write`, writeRet ? 'flushed' : 'queued');
        };

        if (!_this3.isConnected) {
          _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:send attempting to connect. host:${host}, port:${port}`);

          socket.connect({
            port,
            host
          }, () => {
            _this3.log.debug(`[${_this3.socketId}] TcpSocket: socket:send:connect ${socket.localAddress} ${socket.localPort} ${socket.remoteAddress} ${socket.remotePort}`);

            _this3.isConnected = true;
            _this3.isBound = true;
            doWrite();
          });
        } else {
          doWrite();
        }
      });
    })();
  }

}

module.exports = TcpSocket;