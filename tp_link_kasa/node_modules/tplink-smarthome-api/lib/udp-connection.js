'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const TplinkConnection = require('./tplink-connection');

const UdpSocket = require('./udp-socket');

class UdpConnection extends TplinkConnection {
  /**
   * @private
   */
  getSocket(reuseSocket) {
    var _superprop_callGetSocket = (..._args) => super.getSocket(..._args);

    return _asyncToGenerator(function* () {
      return _superprop_callGetSocket(UdpSocket, reuseSocket);
    })();
  } // this.log.debug(`UdpConnection.getUdpSocket(%j)`, { reuseSocket });
  //   if (reuseSocket && this.sharedSocket != null) {
  //     this.log.debug(`UdpConnection.getUdpSocket(): reusing shared socket`);
  //     if (this.sharedSocket.socket != null && this.sharedSocket.isBound) {
  //       return this.sharedSocket;
  //     }
  //     this.log.debug(`UdpConnection.getUdpSocket(): recreating shared socket`);
  //   }
  //   const udpSocket = new UdpSocket(this.client.getNextSocketId(), this.client.log);
  //   await udpSocket.createSocket();
  //   if (reuseSocket) {
  //     udpSocket.unref(); // let node exit cleanly if socket is left open
  //     this.sharedSocket = udpSocket;
  //   }
  //   return udpSocket;
  // }


  send(payload, {
    timeout,
    reuseSocket,
    reuseSocketTimeout
  } = {}) {
    var _this = this;

    return _asyncToGenerator(function* () {
      _this.log.debug(`UdpConnection.send(%j)`, {
        payload,
        timeout,
        reuseSocket,
        reuseSocketTimeout
      });

      if (reuseSocketTimeout != null) {
        _this.setTimeout(reuseSocketTimeout);
      }

      let udpSocket;
      return _this.queue.add(
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        try {
          udpSocket = yield _this.getSocket(reuseSocket);
          let response = yield udpSocket.send(payload, _this.port, _this.host, {
            timeout
          });

          if (!reuseSocket) {
            udpSocket.close();
          }

          return response;
        } catch (err) {
          _this.log.error(`UDP Error: %s`, err);

          if (udpSocket && udpSocket.isBound) udpSocket.close();
          throw err;
        }
      }));
    })();
  }

  close() {
    if (this.sharedSocket && this.sharedSocket.isBound) {
      this.log.debug('UdpConnection.close()');
      this.sharedSocket.close();
    }
  }
  /**
   * @private
   */


  setTimeout(timeout) {
    if (this.timer) {
      clearTimeout(this.timer);
    }

    if (timeout > 0) {
      this.timer = setTimeout(() => {
        this.emit('timeout');
      }, timeout);
    }
  }

}

module.exports = UdpConnection;